; -*- Mode: Lisp; Syntax: Common-Lisp; Package: SCHEME-TRANSLATOR; -*-

; This file was generated by Pseudoscheme 2.12
;  running in CMU Common Lisp 16-Aug-1993
;  from file /zu/jar/pseudo/emit.scm

(ps:in-package "SCHEME-TRANSLATOR")
(BEGIN-TRANSLATED-FILE)
(LOCALLY
 (DECLARE (SPECIAL @TARGET-PACKAGE))
 (SETQ @TARGET-PACKAGE (MAKE-FLUID FALSE)))
(SET-FUNCTION-FROM-VALUE '@TARGET-PACKAGE 'SCHEME::@TARGET-PACKAGE)
(LOCALLY
 (DECLARE (SPECIAL @TRANSLATING-TO-FILE?))
 (SETQ @TRANSLATING-TO-FILE? (MAKE-FLUID FALSE)))
(SET-FUNCTION-FROM-VALUE '@TRANSLATING-TO-FILE? 'SCHEME::@TRANSLATING-TO-FILE?)
(DEFUN EMIT-PROGRAM-VARIABLE-SET! (VAR CL-SYM RHS-CODE)
  (IF (TRUEP (MUTABLE-PROGRAM-VARIABLE? VAR))
      (CONS 'SETQ (CONS CL-SYM (LIST RHS-CODE)))
      (CONS 'SET!-AUX
            (CONS (CONS 'QUOTE (LIST (PROGRAM-VARIABLE-NAME VAR)))
                  (CONS RHS-CODE (LIST (CONS 'QUOTE (LIST CL-SYM))))))))
(SET-VALUE-FROM-FUNCTION 'EMIT-PROGRAM-VARIABLE-SET!
                         'SCHEME::EMIT-PROGRAM-VARIABLE-SET!)
(DEFUN SUBSTITUTE-AND-PEEP (ALIST CL-FORM)
  (IF (SCHEME-SYMBOL-P CL-FORM)
      (LET ((PROBE (TRUE? (ASSOC CL-FORM ALIST :TEST #'EQ))))
        (IF (TRUEP PROBE) (CDR PROBE) CL-FORM))
      (IF (CONSP CL-FORM)
          (LET ((YOW
                 (MAPCAR #'(LAMBDA (Z) (SUBSTITUTE-AND-PEEP ALIST Z)) CL-FORM)))
            (CASE (CAR YOW)
              ((FUNCALL) (FUNCALLIFY (CADR YOW) (CDDR YOW)))
              (OTHERWISE YOW))))))
(SET-VALUE-FROM-FUNCTION 'SUBSTITUTE-AND-PEEP 'SCHEME::SUBSTITUTE-AND-PEEP)
(DEFUN INSERT-&REST (L)
  (IF (NULL (CDR L)) (CONS '&REST L) (CONS (CAR L) (INSERT-&REST (CDR L)))))
(SET-VALUE-FROM-FUNCTION 'INSERT-&REST 'SCHEME::INSERT-&REST)
(DEFUN CL-EXTERNALIZE-LOCALS (VARS ENV)
  (MAPCAR #'(LAMBDA (VAR) (CL-EXTERNALIZE-LOCAL (LOCAL-VARIABLE-NAME VAR) ENV))
          VARS))
(SET-VALUE-FROM-FUNCTION 'CL-EXTERNALIZE-LOCALS 'SCHEME::CL-EXTERNALIZE-LOCALS)
(DEFUN CL-EXTERNALIZE-LOCAL (NAME ENV)
  (IF (TRUEP (QUALIFIED-SYMBOL? NAME))
      NAME
      (IF (TRUEP (NAME-IN-USE? NAME ENV))
          (IN-TARGET-PACKAGE (MAKE-NAME-FROM-UID NAME (GENERATE-UID)))
          (IN-TARGET-PACKAGE (NAME->SYMBOL NAME)))))
(SET-VALUE-FROM-FUNCTION 'CL-EXTERNALIZE-LOCAL 'SCHEME::CL-EXTERNALIZE-LOCAL)
(DEFUN GENERATION-ENV (FREE-VARS)
  (DECLARE (SPECIAL PROGRAM-VARIABLE-NAME))
  (MAPCAR PROGRAM-VARIABLE-NAME FREE-VARS))
(SET-VALUE-FROM-FUNCTION 'GENERATION-ENV 'SCHEME::GENERATION-ENV)
(DEFUN BIND-VARIABLES (VARS NEW-NAMES ENV)
  (MAPC #'(LAMBDA (VAR NEW-NAME) (SET-SUBSTITUTION! VAR NEW-NAME))
        VARS
        NEW-NAMES)
  (GBIND VARS ENV))
(SET-VALUE-FROM-FUNCTION 'BIND-VARIABLES 'SCHEME::BIND-VARIABLES)
(DEFUN BIND-FUNCTIONS (VARS NEW-NAMES ENV)
  (MAPC
   #'(LAMBDA (VAR NEW-NAME)
       (SET-SUBSTITUTION! VAR (CONS 'SCHEME::FUN (LIST NEW-NAME))))
   VARS
   NEW-NAMES)
  (GBIND VARS ENV))
(SET-VALUE-FROM-FUNCTION 'BIND-FUNCTIONS 'SCHEME::BIND-FUNCTIONS)
(DEFUN GBIND (VARS ENV)
  (DECLARE (SPECIAL LOCAL-VARIABLE-NAME))
  (APPEND (MAPCAR LOCAL-VARIABLE-NAME VARS) ENV))
(SET-VALUE-FROM-FUNCTION 'GBIND 'SCHEME::GBIND)
(LOCALLY (DECLARE (SPECIAL NAME-IN-USE? MEMQ)) (SETQ NAME-IN-USE? MEMQ))
(SET-FUNCTION-FROM-VALUE 'NAME-IN-USE? 'SCHEME::NAME-IN-USE?)
(DEFUN MUTABLE-PROGRAM-VARIABLE? (VAR)
  (LET ((NAME (PROGRAM-VARIABLE-NAME VAR)))
    (IF (NOT (TRUEP (QUALIFIED-SYMBOL? NAME)))
        (LET ((S (SYMBOL->STRING NAME)))
          (LET ((N (LENGTH (THE SIMPLE-STRING S))))
            (LET ()
              (IF (>= N 3)
                  (IF (CHAR= (CHAR (THE SIMPLE-STRING S) 0) #\*)
                      (TRUE? (CHAR= (CHAR (THE SIMPLE-STRING S) (- N 1)) #\*))
                      FALSE)
                  FALSE))))
        FALSE)))
(SET-VALUE-FROM-FUNCTION 'MUTABLE-PROGRAM-VARIABLE?
                         'SCHEME::MUTABLE-PROGRAM-VARIABLE?)
(DEFUN IN-TARGET-PACKAGE (SYM)
  (DECLARE (SPECIAL @TARGET-PACKAGE @TRANSLATING-TO-FILE?))
  (IF (TRUEP (FLUID @TRANSLATING-TO-FILE?))
      (CHANGE-PACKAGE SYM (FLUID @TARGET-PACKAGE))
      SYM))
(SET-VALUE-FROM-FUNCTION 'IN-TARGET-PACKAGE 'SCHEME::IN-TARGET-PACKAGE)
(DEFUN CHANGE-PACKAGE (SYM PACKAGE)
  (IF (AND (TRUEP PACKAGE) (NOT (TRUEP (QUALIFIED-SYMBOL? SYM))))
      (INTERN-RENAMING-PERHAPS (SYMBOL->STRING SYM) PACKAGE)
      SYM))
(SET-VALUE-FROM-FUNCTION 'CHANGE-PACKAGE 'SCHEME::CHANGE-PACKAGE)
(DEFUN PROGNIFY (FORM-LIST)
  (IF (NULL (CDR FORM-LIST)) (CAR FORM-LIST) (CONS 'PROGN FORM-LIST)))
(SET-VALUE-FROM-FUNCTION 'PROGNIFY 'SCHEME::PROGNIFY)
(DEFUN DEPROGNIFY (CL-FORM)
  (IF (TRUEP (CAR-IS? CL-FORM 'PROGN)) (CDR CL-FORM) (LIST CL-FORM)))
(SET-VALUE-FROM-FUNCTION 'DEPROGNIFY 'SCHEME::DEPROGNIFY)
(DEFUN DEANDIFY (CL-FORM)
  (IF (TRUEP (CAR-IS? CL-FORM 'AND)) (CDR CL-FORM) (LIST CL-FORM)))
(SET-VALUE-FROM-FUNCTION 'DEANDIFY 'SCHEME::DEANDIFY)
(DEFUN DEORIFY (CL-FORM)
  (IF (TRUEP (CAR-IS? CL-FORM 'OR)) (CDR CL-FORM) (LIST CL-FORM)))
(SET-VALUE-FROM-FUNCTION 'DEORIFY 'SCHEME::DEORIFY)
(DEFUN FUNCALLIFY (FUN ARGS)
  (IF (TRUEP (CAR-IS? FUN 'FUNCTION))
      (LET ((.FUN.0 (CADR FUN)))
        (IF
         (AND (TRUEP (CAR-IS? .FUN.0 'LAMBDA))
              (NOT (MEMBER '&REST (CADR .FUN.0) :TEST #'EQ))
              (= (LENGTH (CADR .FUN.0)) (LENGTH ARGS)))
         (LETIFY (MAPCAR #'LIST (CADR .FUN.0) ARGS) (PROGNIFY (CDDR .FUN.0)))
         (CONS .FUN.0 ARGS)))
      (CONS 'FUNCALL (CONS FUN ARGS))))
(SET-VALUE-FROM-FUNCTION 'FUNCALLIFY 'SCHEME::FUNCALLIFY)
(DEFUN LETIFY (SPECS BODY)
  (IF (NULL SPECS) BODY (CONS 'LET (CONS SPECS (DEPROGNIFY BODY)))))
(SET-VALUE-FROM-FUNCTION 'LETIFY 'SCHEME::LETIFY)
(DEFUN SHARP-QUOTE-LAMBDA? (.EXP)
  (IF (TRUEP (CAR-IS? .EXP 'FUNCTION)) (CAR-IS? (CADR .EXP) 'LAMBDA) FALSE))
(SET-VALUE-FROM-FUNCTION 'SHARP-QUOTE-LAMBDA? 'SCHEME::SHARP-QUOTE-LAMBDA?)
(LOCALLY
 (DECLARE (SPECIAL @CL-VARIABLE-REFERENCES))
 (SETQ @CL-VARIABLE-REFERENCES (MAKE-FLUID 'SCHEME::DONT-ACCUMULATE)))
(SET-FUNCTION-FROM-VALUE '@CL-VARIABLE-REFERENCES
                         'SCHEME::@CL-VARIABLE-REFERENCES)
(DEFUN NOTING-VARIABLE-REFERENCES (THUNK)
  (DECLARE (SPECIAL @CL-VARIABLE-REFERENCES))
  (LET-FLUID @CL-VARIABLE-REFERENCES 'NIL THUNK))
(SET-VALUE-FROM-FUNCTION 'NOTING-VARIABLE-REFERENCES
                         'SCHEME::NOTING-VARIABLE-REFERENCES)
(DEFUN LOCALLY-SPECIALIZE (FORM-LIST)
  (DECLARE (SPECIAL @CL-VARIABLE-REFERENCES PROGRAM-VARIABLE-CL-SYMBOL))
  (LET ((VARS (FLUID @CL-VARIABLE-REFERENCES)))
    (IF
     (OR (NULL VARS)
         (AND (CONSP FORM-LIST)
              (CONSP (CAR FORM-LIST))
              (MEMBER (CAAR FORM-LIST) '(DEFUN DEFSTRUCT DEFTYPE) :TEST #'EQ)))
     FORM-LIST
     (LIST
      (CONS 'LOCALLY
            (CONS
             (CONS 'DECLARE
                   (LIST
                    (CONS 'SPECIAL (MAPCAR PROGRAM-VARIABLE-CL-SYMBOL VARS))))
             FORM-LIST))))))
(SET-VALUE-FROM-FUNCTION 'LOCALLY-SPECIALIZE 'SCHEME::LOCALLY-SPECIALIZE)
(DEFUN EMIT-TOP-LEVEL (CODE)
  (DECLARE (SPECIAL @LAMBDA-ENCOUNTERED?))
  (IF (TRUEP (FLUID @LAMBDA-ENCOUNTERED?))
      (CONS 'AT-TOP-LEVEL CODE)
      (PROGNIFY CODE)))
(SET-VALUE-FROM-FUNCTION 'EMIT-TOP-LEVEL 'SCHEME::EMIT-TOP-LEVEL)
(LOCALLY (DECLARE (SPECIAL CONT/VALUE)) (SETQ CONT/VALUE '(SCHEME::CONT/VALUE)))
(SET-FUNCTION-FROM-VALUE 'CONT/VALUE 'SCHEME::CONT/VALUE)
(LOCALLY
 (DECLARE (SPECIAL CONT/RETURN))
 (SETQ CONT/RETURN '(SCHEME::CONT/RETURN)))
(SET-FUNCTION-FROM-VALUE 'CONT/RETURN 'SCHEME::CONT/RETURN)
(LOCALLY (DECLARE (SPECIAL CONT/TEST)) (SETQ CONT/TEST '(SCHEME::CONT/TEST)))
(SET-FUNCTION-FROM-VALUE 'CONT/TEST 'SCHEME::CONT/TEST)
(LOCALLY
 (DECLARE (SPECIAL CONT/IGNORE))
 (SETQ CONT/IGNORE '(SCHEME::CONT/IGNORE)))
(SET-FUNCTION-FROM-VALUE 'CONT/IGNORE 'SCHEME::CONT/IGNORE)
(LOCALLY (DECLARE (SPECIAL CONTINUATION-TYPE)) (SETQ CONTINUATION-TYPE #'CAR))
(SET-FUNCTION-FROM-VALUE 'CONTINUATION-TYPE 'SCHEME::CONTINUATION-TYPE)
(DEFUN DELIVER-VALUE-TO-CONT (RESULT-EXP CONT)
  (CASE (CONTINUATION-TYPE CONT)
    ((SCHEME::CONT/VALUE SCHEME::CONT/IGNORE) RESULT-EXP)
    ((SCHEME::CONT/RETURN) (CONS 'RETURN (LIST RESULT-EXP)))
    ((SCHEME::CONT/TEST) (VALUE-FORM->TEST-FORM RESULT-EXP))
    (OTHERWISE (.ERROR "unrecognized continuation" CONT))))
(SET-VALUE-FROM-FUNCTION 'DELIVER-VALUE-TO-CONT 'SCHEME::DELIVER-VALUE-TO-CONT)
(DEFUN DELIVER-TEST-TO-CONT (TEST-EXP CONT)
  (CASE (CONTINUATION-TYPE CONT)
    ((SCHEME::CONT/TEST SCHEME::CONT/IGNORE) TEST-EXP)
    ((SCHEME::CONT/RETURN)
     (CONS 'RETURN (LIST (TEST-FORM->VALUE-FORM TEST-EXP))))
    ((SCHEME::CONT/VALUE) (TEST-FORM->VALUE-FORM TEST-EXP))
    (OTHERWISE (.ERROR "unrecognized continuation" CONT))))
(SET-VALUE-FROM-FUNCTION 'DELIVER-TEST-TO-CONT 'SCHEME::DELIVER-TEST-TO-CONT)
(DEFUN TEST-FORM->VALUE-FORM (CL-FORM) (CONS 'TRUE? (LIST CL-FORM)))
(SET-VALUE-FROM-FUNCTION 'TEST-FORM->VALUE-FORM 'SCHEME::TEST-FORM->VALUE-FORM)
(DEFUN VALUE-FORM->TEST-FORM (CL-FORM)
  (IF (TRUEP (CAR-IS? CL-FORM 'TRUE?))
      (CADR CL-FORM)
      (CONS 'TRUEP (LIST CL-FORM))))
(SET-VALUE-FROM-FUNCTION 'VALUE-FORM->TEST-FORM 'SCHEME::VALUE-FORM->TEST-FORM)
