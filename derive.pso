; -*- Mode: Lisp; Syntax: Common-Lisp; Package: SCHEME-TRANSLATOR; -*-

; This file was generated by Pseudoscheme 2.12
;  running in CMU Common Lisp 16-Aug-1993
;  from file /zu/jar/pseudo/derive.scm

(ps:in-package "SCHEME-TRANSLATOR")
(BEGIN-TRANSLATED-FILE)
(DEFUN DEFINE-USUAL-SYNTAX (NAME EXPANDER)
  (DECLARE (SPECIAL REVISED^4-SCHEME-ENV))
  (PROGRAM-ENV-DEFINE! REVISED^4-SCHEME-ENV
                       NAME
                       (MAKE-MACRO
                        #'(LAMBDA (FORM R C) (APPLY EXPANDER R C (CDR FORM)))
                        REVISED^4-SCHEME-ENV)))
(SET-VALUE-FROM-FUNCTION 'DEFINE-USUAL-SYNTAX 'SCHEME::DEFINE-USUAL-SYNTAX)
(LOCALLY
 (DECLARE (SPECIAL REWRITE-SYNTAX-RULES REVISED^4-SCHEME-ENV))
 (PROGRAM-ENV-DEFINE! REVISED^4-SCHEME-ENV
                      'SCHEME::SYNTAX-RULES
                      (MAKE-MACRO REWRITE-SYNTAX-RULES REVISED^4-SCHEME-ENV)))
(AT-TOP-LEVEL
 (DEFINE-USUAL-SYNTAX 'SCHEME::AND
                      #'(LAMBDA (R C &REST CONJUNCTS)
                          (MAYBE-FIX-&REST-PARAMETER CONJUNCTS)
                          C
                          (IF (NULL CONJUNCTS)
                              TRUE
                              (LABELS ((RECUR (FIRST REST)
                                         (IF (NULL REST)
                                             FIRST
                                             (CONS (FUNCALL R 'SCHEME::AND-AUX)
                                                   (CONS FIRST
                                                         (LIST
                                                          (CONS
                                                           (FUNCALL R
                                                                    'SCHEME::LAMBDA)
                                                           (CONS 'NIL
                                                                 (LIST
                                                                  (RECUR
                                                                   (CAR REST)
                                                                   (CDR
                                                                    REST)))))))))))
                                (RECUR (CAR CONJUNCTS) (CDR CONJUNCTS)))))))
(AT-TOP-LEVEL
 (DEFINE-USUAL-SYNTAX 'SCHEME::OR
                      #'(LAMBDA (R C &REST DISJUNCTS)
                          (MAYBE-FIX-&REST-PARAMETER DISJUNCTS)
                          C
                          (IF (NULL DISJUNCTS)
                              FALSE
                              (LABELS ((RECUR (FIRST REST)
                                         (IF (NULL REST)
                                             FIRST
                                             (CONS (FUNCALL R 'SCHEME::OR-AUX)
                                                   (CONS FIRST
                                                         (LIST
                                                          (CONS
                                                           (FUNCALL R
                                                                    'SCHEME::LAMBDA)
                                                           (CONS 'NIL
                                                                 (LIST
                                                                  (RECUR
                                                                   (CAR REST)
                                                                   (CDR
                                                                    REST)))))))))))
                                (RECUR (CAR DISJUNCTS) (CDR DISJUNCTS)))))))
(AT-TOP-LEVEL
 (DEFINE-USUAL-SYNTAX 'SCHEME::CASE
                      #'(LAMBDA (R C KEY &REST CLAUSES)
                          (MAYBE-FIX-&REST-PARAMETER CLAUSES)
                          (FLET ((FORM-RESULT (ELSE-THUNK THUNKS KEY-LISTS)
                                   (CONS (FUNCALL R 'SCHEME::CASE-AUX)
                                         (CONS KEY
                                               (CONS
                                                (CONS
                                                 (FUNCALL R 'SCHEME::QUOTE)
                                                 (LIST (REVERSE KEY-LISTS)))
                                                (CONS ELSE-THUNK
                                                      (REVERSE THUNKS)))))))
                            (PROG (CS THUNKS KEY-LISTS)
                              (PSETQ CS CLAUSES THUNKS 'NIL KEY-LISTS 'NIL)
                              (GO LOOP)
                             LOOP
                              (IF (NULL CS)
                                  (RETURN
                                   (FORM-RESULT
                                    (CONS (FUNCALL R 'SCHEME::LAMBDA)
                                          (CONS 'NIL
                                                (LIST
                                                 (FUNCALL R
                                                          'SCHEME::UNSPECIFIC))))
                                    THUNKS KEY-LISTS))
                                  (LET ((CLAUSE (CAR CS)))
                                    (LET ((KEY-LIST (CAR CLAUSE)))
                                      (LET ((BODY (CDR CLAUSE)))
                                        (LET ()
                                          (IF
                                           (TRUEP
                                            (FUNCALL C
                                                     KEY-LIST
                                                     (FUNCALL R
                                                              'SCHEME::ELSE)))
                                           (RETURN
                                            (FORM-RESULT
                                             (CONS (FUNCALL R 'SCHEME::LAMBDA)
                                                   (CONS 'NIL BODY))
                                             THUNKS KEY-LISTS))
                                           (PROGN
                                            (PSETQ CS
                                                     (CDR CS)
                                                   THUNKS
                                                     (CONS
                                                      (CONS
                                                       (FUNCALL R
                                                                'SCHEME::LAMBDA)
                                                       (CONS 'NIL BODY))
                                                      THUNKS)
                                                   KEY-LISTS
                                                     (CONS KEY-LIST KEY-LISTS))
                                            (GO LOOP)))))))))))))
(AT-TOP-LEVEL
 (DEFINE-USUAL-SYNTAX 'SCHEME::COND
                      #'(LAMBDA (R C &REST CLAUSES)
                          (MAYBE-FIX-&REST-PARAMETER CLAUSES)
                          (LABELS ((RECUR (.CLAUSES.0)
                                     (IF (NULL .CLAUSES.0)
                                         (FUNCALL R 'SCHEME::UNSPECIFIC)
                                         (PROCESS-COND-CLAUSE R
                                                              C
                                                              (CAR .CLAUSES.0)
                                                              (RECUR
                                                               (CDR
                                                                .CLAUSES.0))))))
                            (RECUR CLAUSES)))))
(DEFUN PROCESS-COND-CLAUSE (R C CLAUSE REST)
  (IF (NULL (CDR CLAUSE))
      (CONS (FUNCALL R 'SCHEME::OR-AUX)
            (CONS (CAR CLAUSE)
                  (LIST
                   (CONS (FUNCALL R 'SCHEME::LAMBDA)
                         (CONS 'NIL (LIST REST))))))
      (IF (TRUEP (FUNCALL C (CAR CLAUSE) (FUNCALL R 'SCHEME::ELSE)))
          (CONS (FUNCALL R 'SCHEME::BEGIN) (CDR CLAUSE))
          (IF (TRUEP (FUNCALL C (CADR CLAUSE) (FUNCALL R 'SCHEME::=>)))
              (CONS (FUNCALL R 'SCHEME::=>-AUX)
                    (CONS (CAR CLAUSE)
                          (CONS
                           (CONS (FUNCALL R 'SCHEME::LAMBDA)
                                 (CONS 'NIL (LIST (CADDR CLAUSE))))
                           (LIST
                            (CONS (FUNCALL R 'SCHEME::LAMBDA)
                                  (CONS 'NIL (LIST REST)))))))
              (CONS (FUNCALL R 'SCHEME::IF)
                    (CONS (CAR CLAUSE)
                          (CONS (CONS (FUNCALL R 'SCHEME::BEGIN) (CDR CLAUSE))
                                (LIST REST))))))))
(SET-VALUE-FROM-FUNCTION 'PROCESS-COND-CLAUSE 'SCHEME::PROCESS-COND-CLAUSE)
(AT-TOP-LEVEL
 (DEFINE-USUAL-SYNTAX 'SCHEME::DELAY
                      #'(LAMBDA (R C THING)
                          C
                          (CONS (FUNCALL R 'SCHEME::MAKE-PROMISE)
                                (LIST
                                 (CONS (FUNCALL R 'SCHEME::LAMBDA)
                                       (CONS 'NIL (LIST THING))))))))
(AT-TOP-LEVEL
 (DEFINE-USUAL-SYNTAX 'SCHEME::DO
                      #'(LAMBDA (R C SPECS END &REST BODY)
                          (MAYBE-FIX-&REST-PARAMETER BODY)
                          C
                          (LET ((LOOP (FUNCALL R 'SCHEME::LOOP)))
                            (CONS (FUNCALL R 'SCHEME::LETREC)
                                  (CONS
                                   (LIST
                                    (CONS LOOP
                                          (LIST
                                           (CONS (FUNCALL R 'SCHEME::LAMBDA)
                                                 (CONS (MAPCAR #'CAR SPECS)
                                                       (LIST
                                                        (PROCESS-COND-CLAUSE R
                                                                             C
                                                                             END
                                                                             (CONS
                                                                              (FUNCALL
                                                                               R
                                                                               'SCHEME::BEGIN)
                                                                              (APPEND
                                                                               BODY
                                                                               (LIST
                                                                                (CONS
                                                                                 LOOP
                                                                                 (MAPCAR
                                                                                  #'(LAMBDA
                                                                                        (Y)
                                                                                      (IF
                                                                                       (NULL
                                                                                        (CDDR
                                                                                         Y))
                                                                                       (CAR
                                                                                        Y)
                                                                                       (CADDR
                                                                                        Y)))
                                                                                  SPECS))))))))))))
                                   (LIST
                                    (CONS LOOP (MAPCAR #'CADR SPECS)))))))))
(AT-TOP-LEVEL
 (DEFINE-USUAL-SYNTAX 'SCHEME::LET
                      #'(LAMBDA (R C SPECS &REST BODY)
                          (MAYBE-FIX-&REST-PARAMETER BODY)
                          C
                          (IF (TRUEP (NAME? SPECS))
                              (LET ((TAG SPECS)
                                    (.SPECS.0 (CAR BODY))
                                    (.BODY.1 (CDR BODY)))
                                (CONS (FUNCALL R 'SCHEME::LETREC)
                                      (CONS
                                       (LIST
                                        (CONS TAG
                                              (LIST
                                               (CONS
                                                (FUNCALL R 'SCHEME::LAMBDA)
                                                (CONS (MAPCAR #'CAR .SPECS.0)
                                                      .BODY.1)))))
                                       (LIST
                                        (CONS TAG (MAPCAR #'CADR .SPECS.0))))))
                              (CONS
                               (CONS (FUNCALL R 'SCHEME::LAMBDA)
                                     (CONS (MAPCAR #'CAR SPECS) BODY))
                               (MAPCAR #'CADR SPECS))))))
(AT-TOP-LEVEL
 (DEFINE-USUAL-SYNTAX 'SCHEME::LET*
                      #'(LAMBDA (R C SPECS &REST BODY)
                          (MAYBE-FIX-&REST-PARAMETER BODY)
                          C
                          (LABELS ((RECUR (.SPECS.0)
                                     (IF (NULL .SPECS.0)
                                         (CONS (FUNCALL R 'SCHEME::LET)
                                               (CONS 'NIL BODY))
                                         (LET ((NAME (CAR (CAR .SPECS.0)))
                                               (VAL-EXP (CADR (CAR .SPECS.0))))
                                           (CONS (FUNCALL R 'SCHEME::LET)
                                                 (CONS
                                                  (LIST
                                                   (CONS NAME (LIST VAL-EXP)))
                                                  (LIST
                                                   (RECUR (CDR .SPECS.0)))))))))
                            (RECUR SPECS)))))
(AT-TOP-LEVEL
 (DEFINE-USUAL-SYNTAX 'SCHEME::QUASIQUOTE
                      #'(LAMBDA (R C X) C (QQ-DESCEND X 1 R))))
(DEFUN QQ-DESCEND (X LEVEL R)
  (IF (TRUEP (VECTOR? X))
      (QQ-DESCEND-VECTOR X LEVEL R)
      (IF (NOT (CONSP X))
          (MAKE-QUOTATION X R)
          (IF (TRUEP (QQ-INTERESTING? X 'SCHEME::QUASIQUOTE))
              (QQ-DESCEND-PAIR X (+ LEVEL 1) R)
              (IF (TRUEP (QQ-INTERESTING? X 'SCHEME::UNQUOTE))
                  (IF (= LEVEL 1) (CADR X) (QQ-DESCEND-PAIR X (- LEVEL 1) R))
                  (IF (TRUEP (QQ-INTERESTING? X 'SCHEME::UNQUOTE-SPLICING))
                      (IF (= LEVEL 1)
                          (.ERROR ",@ in illegal position" X)
                          (QQ-DESCEND-PAIR X (- LEVEL 1) R))
                      (QQ-DESCEND-PAIR X LEVEL R)))))))
(SET-VALUE-FROM-FUNCTION 'QQ-DESCEND 'SCHEME::QQ-DESCEND)
(DEFUN QQ-DESCEND-PAIR (X LEVEL R)
  (LET ((D-EXP (QQ-DESCEND (CDR X) LEVEL R)))
    (IF
     (AND (TRUEP (QQ-INTERESTING? (CAR X) 'SCHEME::UNQUOTE-SPLICING))
          (= LEVEL 1))
     (LET ((SC (CADR (CAR X))))
       (IF (AND (TRUEP (QUOTATION? D-EXP R)) (NULL (QUOTATION-VALUE D-EXP)))
           SC
           (CONS (FUNCALL R 'SCHEME::APPEND) (CONS SC (LIST D-EXP)))))
     (LET ((A-EXP (QQ-DESCEND (CAR X) LEVEL R)))
       (IF (AND (TRUEP (QUOTATION? A-EXP R)) (TRUEP (QUOTATION? D-EXP R)))
           (MAKE-QUOTATION X R)
           (IF
            (AND (TRUEP (QUOTATION? D-EXP R))
                 (EQ (QUOTATION-VALUE D-EXP) 'NIL))
            (CONS (FUNCALL R 'SCHEME::LIST) (LIST A-EXP))
            (IF (TRUEP (QQ-INTERESTING? D-EXP 'SCHEME::LIST))
                (CONS (FUNCALL R 'SCHEME::LIST) (CONS A-EXP (CDR D-EXP)))
                (CONS (FUNCALL R 'SCHEME::CONS)
                      (CONS A-EXP (LIST D-EXP))))))))))
(SET-VALUE-FROM-FUNCTION 'QQ-DESCEND-PAIR 'SCHEME::QQ-DESCEND-PAIR)
(DEFUN QQ-DESCEND-VECTOR (X LEVEL R)
  (LET ((RESULT (QQ-DESCEND (COERCE (THE SIMPLE-VECTOR X) 'LIST) LEVEL R)))
    (IF (TRUEP (QUOTATION? RESULT R))
        (MAKE-QUOTATION X R)
        (CONS (FUNCALL R 'SCHEME::LIST->VECTOR) (LIST RESULT)))))
(SET-VALUE-FROM-FUNCTION 'QQ-DESCEND-VECTOR 'SCHEME::QQ-DESCEND-VECTOR)
(DEFUN QQ-INTERESTING? (X MARKER)
  (IF (CONSP X)
      (IF (EQ (CAR X) MARKER)
          (IF (CONSP (CDR X)) (TRUE? (NULL (CDDR X))) FALSE)
          FALSE)
      FALSE))
(SET-VALUE-FROM-FUNCTION 'QQ-INTERESTING? 'SCHEME::QQ-INTERESTING?)
(DEFUN QUOTATION? (X R) (QQ-INTERESTING? X (FUNCALL R 'SCHEME::QUOTE)))
(SET-VALUE-FROM-FUNCTION 'QUOTATION? 'SCHEME::QUOTATION?)
(LOCALLY (DECLARE (SPECIAL QUOTATION-VALUE)) (SETQ QUOTATION-VALUE #'CADR))
(SET-FUNCTION-FROM-VALUE 'QUOTATION-VALUE 'SCHEME::QUOTATION-VALUE)
(DEFUN MAKE-QUOTATION (VALUE R) (CONS (FUNCALL R 'SCHEME::QUOTE) (LIST VALUE)))
(SET-VALUE-FROM-FUNCTION 'MAKE-QUOTATION 'SCHEME::MAKE-QUOTATION)
