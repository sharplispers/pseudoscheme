; -*- Mode: Lisp; Syntax: Common-Lisp; Package: SCHEME-TRANSLATOR; -*-

; This file was generated by Pseudoscheme 2.12
;  running in CMU Common Lisp 16-Aug-1993
;  from file /zu/jar/pseudo/strategy.scm

(ps:in-package "SCHEME-TRANSLATOR")
(BEGIN-TRANSLATED-FILE)
(DEFUN GET-LETREC-STRATEGY (NODE)
  (DECLARE (SPECIAL N-ARY? VARIABLE-VALUE-REFS?))
  (LET ((TEMP (LETREC-STRATEGY NODE)))
    (IF (TRUEP TEMP)
        TEMP
        (LET ((STRATEGY
               (LET ((VARS (LETREC-VARS NODE)) (VALS (LETREC-VALS NODE)))
                 (IF
                  (OR (NULL VARS) (NOT (TRUEP (FUNCTION-BINDABLE? VARS VALS))))
                  'SCHEME::GENERAL
                  (IF
                   (OR (TRUEP (SOME VARIABLE-VALUE-REFS? VARS))
                       (TRUEP (SOME N-ARY? VALS))
                       (TRUEP (EXISTS-LOSING-CALL? NODE)))
                   'SCHEME::LABELS
                   'SCHEME::PROG)))))
          (SET-LETREC-STRATEGY! NODE STRATEGY)
          STRATEGY))))
(SET-VALUE-FROM-FUNCTION 'GET-LETREC-STRATEGY 'SCHEME::GET-LETREC-STRATEGY)
(DEFUN EXISTS-LOSING-CALL? (NODE)
  (LET ((VARS (LETREC-VARS NODE)))
    (LET ((TEMP (CONTAINS-LOSER? (LETREC-BODY NODE) VARS 'SCHEME::WIN)))
      (IF (TRUEP TEMP)
          TEMP
          (SOME #'(LAMBDA (PROC) (CALL-WILL-LOSE? PROC VARS 'SCHEME::WIN))
                (LETREC-VALS NODE))))))
(SET-VALUE-FROM-FUNCTION 'EXISTS-LOSING-CALL? 'SCHEME::EXISTS-LOSING-CALL?)
(DEFUN CONTAINS-LOSER? (NODE VARS K)
  (CASE (NODE-TYPE NODE)
    ((SCHEME::LOCAL-VARIABLE SCHEME::PROGRAM-VARIABLE SCHEME::CONSTANT) FALSE)
    ((SCHEME::LETREC)
     (LET ((TEMP (CONTAINS-LOSER? (LETREC-BODY NODE) VARS K)))
       (IF (TRUEP TEMP)
           TEMP
           (IF (EQ (GET-LETREC-STRATEGY NODE) 'SCHEME::PROG)
               (SOME #'(LAMBDA (PROC) (CALL-WILL-LOSE? PROC VARS K))
                     (LETREC-VALS NODE))
               (LIST-CONTAINS-LOSER? (LETREC-VALS NODE) VARS 'SCHEME::LOSE)))))
    ((SCHEME::IF)
     (LET ((TEMP (CONTAINS-LOSER? (IF-TEST NODE) VARS 'SCHEME::LOSE)))
       (IF (TRUEP TEMP)
           TEMP
           (LET ((.TEMP.0 (CONTAINS-LOSER? (IF-CON NODE) VARS K)))
             (IF (TRUEP .TEMP.0)
                 .TEMP.0
                 (CONTAINS-LOSER? (IF-ALT NODE) VARS K))))))
    ((SCHEME::BEGIN)
     (LET ((TEMP (CONTAINS-LOSER? (BEGIN-FIRST NODE) VARS 'SCHEME::LOSE)))
       (IF (TRUEP TEMP) TEMP (CONTAINS-LOSER? (BEGIN-SECOND NODE) VARS K))))
    ((SCHEME::SET!) (CONTAINS-LOSER? (SET!-RHS NODE) VARS 'SCHEME::LOSE))
    ((SCHEME::LAMBDA) (CONTAINS-LOSER? (LAMBDA-BODY NODE) VARS 'SCHEME::LOSE))
    ((SCHEME::CALL)
     (LET ((PROC (CALL-PROC NODE)))
       (IF (TRUEP (LAMBDA? PROC))
           (LET ((TEMP (CALL-WILL-LOSE? PROC VARS K)))
             (IF (TRUEP TEMP)
                 TEMP
                 (LIST-CONTAINS-LOSER? (CALL-ARGS NODE) VARS 'SCHEME::LOSE)))
           (IF (TRUEP (PROGRAM-VARIABLE? PROC))
               (LET ((N (NUMBER-OF-NON-CONTINUATION-ARGS PROC)))
                 (IF (TRUEP N)
                     (PROG (|.A.1| |.I.2|)
                       (PSETQ |.A.1| (CALL-ARGS NODE) |.I.2| 0)
                       (GO LOOP)
                      LOOP
                       (LET ((A |.A.1|) (I |.I.2|))
                         (IF (= I N)
                             (RETURN
                              (SOME
                               #'(LAMBDA (ARG) (CALL-WILL-LOSE? ARG VARS K))
                               A))
                             (LET ((TEMP
                                    (CONTAINS-LOSER? (CAR A)
                                                     VARS
                                                     'SCHEME::LOSE)))
                               (IF (TRUEP TEMP)
                                   (RETURN TEMP)
                                   (PROGN
                                    (PSETQ |.A.1| (CDR A) |.I.2| (+ I 1))
                                    (GO LOOP)))))))
                     (LIST-CONTAINS-LOSER? (CALL-ARGS NODE)
                                           VARS
                                           'SCHEME::LOSE)))
               (LET ((TEMP
                      (IF (MEMBER PROC VARS :TEST #'EQ)
                          (TRUE? (EQ K 'SCHEME::LOSE))
                          (CONTAINS-LOSER? PROC VARS 'SCHEME::LOSE))))
                 (IF (TRUEP TEMP)
                     TEMP
                     (LIST-CONTAINS-LOSER? (CALL-ARGS NODE)
                                           VARS
                                           'SCHEME::LOSE)))))))
    (OTHERWISE (.ERROR "unknown node type" NODE))))
(SET-VALUE-FROM-FUNCTION 'CONTAINS-LOSER? 'SCHEME::CONTAINS-LOSER?)
(DEFUN LIST-CONTAINS-LOSER? (NODE-LIST VARS K)
  (SOME #'(LAMBDA (NODE) (CONTAINS-LOSER? NODE VARS K)) NODE-LIST))
(SET-VALUE-FROM-FUNCTION 'LIST-CONTAINS-LOSER? 'SCHEME::LIST-CONTAINS-LOSER?)
(DEFUN CALL-WILL-LOSE? (PROC-NODE VARS K)
  (IF (TRUEP (LAMBDA? PROC-NODE))
      (CONTAINS-LOSER? (LAMBDA-BODY PROC-NODE) VARS K)
      (CONTAINS-LOSER? PROC-NODE VARS 'SCHEME::LOSE)))
(SET-VALUE-FROM-FUNCTION 'CALL-WILL-LOSE? 'SCHEME::CALL-WILL-LOSE?)
(DEFUN NUMBER-OF-NON-CONTINUATION-ARGS (VAR)
  (IF
   (OR (EQ VAR (BUILT-IN 'SCHEME::AND-AUX))
       (EQ VAR (BUILT-IN 'SCHEME::OR-AUX)))
   1
   (IF (EQ VAR (BUILT-IN 'SCHEME::=>-AUX))
       2
       (IF (EQ VAR (BUILT-IN 'SCHEME::CASE-AUX)) 1 FALSE))))
(SET-VALUE-FROM-FUNCTION 'NUMBER-OF-NON-CONTINUATION-ARGS
                         'SCHEME::NUMBER-OF-NON-CONTINUATION-ARGS)
(DEFUN FUNCTION-BINDABLE? (VARS VALS)
  (DECLARE (SPECIAL LAMBDA?))
  (IF (NOT (NULL VARS))
      (IF
       (TRUEP
        (EVERY #'(LAMBDA (VAR) (TRUE? (NOT (TRUEP (VARIABLE-ASSIGNED? VAR)))))
               VARS))
       (EVERY LAMBDA? VALS)
       FALSE)
      FALSE))
(SET-VALUE-FROM-FUNCTION 'FUNCTION-BINDABLE? 'SCHEME::FUNCTION-BINDABLE?)
