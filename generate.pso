; -*- Mode: Lisp; Syntax: Common-Lisp; Package: SCHEME-TRANSLATOR; -*-

; This file was generated by Pseudoscheme 2.12
;  running in CMU Common Lisp 16-Aug-1993
;  from file /zu/jar/pseudo/generate.scm

(ps:in-package "SCHEME-TRANSLATOR")
(BEGIN-TRANSLATED-FILE)
(LOCALLY
 (DECLARE (SPECIAL PROGRAM-VARIABLE-CL-SYMBOL PROGRAM-VARIABLE-LOCATION))
 (SETQ PROGRAM-VARIABLE-CL-SYMBOL PROGRAM-VARIABLE-LOCATION))
(SET-FUNCTION-FROM-VALUE 'PROGRAM-VARIABLE-CL-SYMBOL
                         'SCHEME::PROGRAM-VARIABLE-CL-SYMBOL)
(LOCALLY
 (DECLARE (SPECIAL @LAMBDA-ENCOUNTERED?))
 (SETQ @LAMBDA-ENCOUNTERED? (MAKE-FLUID FALSE)))
(SET-FUNCTION-FROM-VALUE '@LAMBDA-ENCOUNTERED? 'SCHEME::@LAMBDA-ENCOUNTERED?)
(DEFUN GENERATE-TOP (NODE ENV IGNORE?)
  (CASE (NODE-TYPE NODE)
    ((SCHEME::BEGIN)
     (PROGNIFY
      (APPEND (DEPROGNIFY (GENERATE-TOP (BEGIN-FIRST NODE) ENV TRUE))
              (DEPROGNIFY (GENERATE-TOP (BEGIN-SECOND NODE) ENV IGNORE?)))))
    ((SCHEME::DEFINE) (GENERATE-DEFINE NODE ENV))
    (OTHERWISE (GENERATE-EXPRESSION-TOP NODE ENV IGNORE?))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-TOP 'SCHEME::GENERATE-TOP)
(DEFUN GENERATE-DEFINE (DEF ENV)
  (DECLARE (SPECIAL @WHERE))
  (LET ((LHS (DEFINE-LHS DEF)))
    (LET-FLUID @WHERE
               (PROGRAM-VARIABLE-NAME LHS)
               #'(LAMBDA ()
                   (LET ((RHS (DEFINE-RHS DEF))
                         (CL-SYM (PROGRAM-VARIABLE-CL-SYMBOL LHS))
                         (NAME (PROGRAM-VARIABLE-NAME LHS)))
                     (IF (TRUEP (MUTABLE-PROGRAM-VARIABLE? LHS))
                         (CONS 'PROGN
                               (CONS (GENERATE-SETQ-TOP LHS RHS ENV)
                                     (LIST
                                      (CONS 'SET-FORWARDING-FUNCTION
                                            (CONS (CONS 'QUOTE (LIST CL-SYM))
                                                  (LIST
                                                   (CONS 'QUOTE
                                                         (LIST NAME))))))))
                         (IF (TRUEP (LAMBDA? RHS))
                             (CONS 'PROGN
                                   (CONS
                                    (CONS 'DEFUN
                                          (CONS CL-SYM
                                                (CDR
                                                 (GENERATE-LAMBDA-TOP RHS
                                                                      ENV))))
                                    (LIST
                                     (CONS 'SET-VALUE-FROM-FUNCTION
                                           (CONS (CONS 'QUOTE (LIST CL-SYM))
                                                 (LIST
                                                  (CONS 'QUOTE
                                                        (LIST NAME))))))))
                             (CONS 'PROGN
                                   (CONS (GENERATE-SETQ-TOP LHS RHS ENV)
                                         (LIST
                                          (CONS 'SET-FUNCTION-FROM-VALUE
                                                (CONS
                                                 (CONS 'QUOTE (LIST CL-SYM))
                                                 (LIST
                                                  (CONS 'QUOTE
                                                        (LIST
                                                         NAME)))))))))))))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-DEFINE 'SCHEME::GENERATE-DEFINE)
(DEFUN GENERATE-EXPRESSION-TOP (NODE ENV IGNORE?)
  (DECLARE (SPECIAL CONT/VALUE CONT/IGNORE @LAMBDA-ENCOUNTERED?))
  (LET-FLUID @LAMBDA-ENCOUNTERED?
             FALSE
             #'(LAMBDA ()
                 (NOTING-VARIABLE-REFERENCES
                  #'(LAMBDA ()
                      (LET ((CODE
                             (GENERATE NODE
                                       ENV
                                       (IF (TRUEP IGNORE?)
                                           CONT/IGNORE
                                           CONT/VALUE))))
                        (EMIT-TOP-LEVEL
                         (LOCALLY-SPECIALIZE (DEPROGNIFY CODE)))))))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-EXPRESSION-TOP
                         'SCHEME::GENERATE-EXPRESSION-TOP)
(DEFUN GENERATE-LAMBDA-TOP (NODE ENV)
  (DECLARE (SPECIAL CONT/VALUE @LAMBDA-ENCOUNTERED?))
  (LET-FLUID @LAMBDA-ENCOUNTERED?
             FALSE
             #'(LAMBDA ()
                 (NOTING-VARIABLE-REFERENCES
                  #'(LAMBDA ()
                      (LET ((BVL+BODY
                             (GENERATE-LAMBDA-AUX NODE ENV CONT/VALUE)))
                        (LET ((BODY (LOCALLY-SPECIALIZE (CDR BVL+BODY))))
                          (LET ()
                            (CONS 'LAMBDA
                                  (CONS (CAR BVL+BODY)
                                        (IF
                                         (AND (CONSP BODY)
                                              (NULL (CDR BODY))
                                              (TRUEP
                                               (CAR-IS? (CAR BODY) 'LOCALLY)))
                                         (CDR (CAR BODY))
                                         BODY)))))))))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-LAMBDA-TOP 'SCHEME::GENERATE-LAMBDA-TOP)
(DEFUN GENERATE-SETQ-TOP (LHS RHS ENV)
  (DECLARE (SPECIAL CONT/IGNORE @LAMBDA-ENCOUNTERED?))
  (LET-FLUID @LAMBDA-ENCOUNTERED?
             FALSE
             #'(LAMBDA ()
                 (NOTING-VARIABLE-REFERENCES
                  #'(LAMBDA ()
                      (LET ((CODE (GENERATE RHS ENV CONT/IGNORE)))
                        (NOTE-VARIABLE-REFERENCE! LHS)
                        (EMIT-TOP-LEVEL
                         (LOCALLY-SPECIALIZE
                          (LIST
                           (CONS 'SETQ
                                 (CONS (PROGRAM-VARIABLE-CL-SYMBOL LHS)
                                       (LIST CODE))))))))))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-SETQ-TOP 'SCHEME::GENERATE-SETQ-TOP)
(DEFUN GENERATE (NODE ENV CONT)
  (CASE (NODE-TYPE NODE)
    ((SCHEME::LOCAL-VARIABLE) (GENERATE-LOCAL-VARIABLE NODE ENV CONT))
    ((SCHEME::PROGRAM-VARIABLE) (GENERATE-PROGRAM-VARIABLE NODE ENV CONT))
    ((SCHEME::CONSTANT) (GENERATE-CONSTANT NODE ENV CONT))
    ((SCHEME::CALL) (GENERATE-CALL NODE ENV CONT))
    ((SCHEME::LAMBDA) (GENERATE-LAMBDA NODE ENV CONT))
    ((SCHEME::LETREC) (GENERATE-LETREC NODE ENV CONT))
    ((SCHEME::IF) (GENERATE-IF NODE ENV CONT))
    ((SCHEME::BEGIN) (GENERATE-BEGIN NODE ENV CONT))
    ((SCHEME::SET!) (GENERATE-SET! NODE ENV CONT))
    (OTHERWISE (NOTE "don't know how to generate" NODE))))
(SET-VALUE-FROM-FUNCTION 'GENERATE 'SCHEME::GENERATE)
(DEFUN GENERATE-LIST (NODE-LIST ENV)
  (DECLARE (SPECIAL CONT/VALUE))
  (MAPCAR #'(LAMBDA (NODE) (GENERATE NODE ENV CONT/VALUE)) NODE-LIST))
(SET-VALUE-FROM-FUNCTION 'GENERATE-LIST 'SCHEME::GENERATE-LIST)
(DEFUN GENERATE-BODY (NODE ENV CONT) (DEPROGNIFY (GENERATE NODE ENV CONT)))
(SET-VALUE-FROM-FUNCTION 'GENERATE-BODY 'SCHEME::GENERATE-BODY)
(DEFUN GENERATE-CONSTANT (NODE ENV CONT)
  ENV
  (LET ((VAL (CONSTANT-VALUE NODE)))
    (IF (TRUEP (CONSTANT-QUOTED? NODE))
        (DELIVER-VALUE-TO-CONT (CONS 'QUOTE (LIST VAL)) CONT)
        (IF (EQ VAL TRUE)
            (DELIVER-VALUE-TO-CONT 'TRUE CONT)
            (IF (EQ VAL FALSE)
                (IF (EQ (CONTINUATION-TYPE CONT) 'SCHEME::CONT/TEST)
                    'NIL
                    (DELIVER-VALUE-TO-CONT 'FALSE CONT))
                (DELIVER-VALUE-TO-CONT VAL CONT))))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-CONSTANT 'SCHEME::GENERATE-CONSTANT)
(DEFUN GENERATE-LOCAL-VARIABLE (VAR ENV CONT)
  ENV
  (LET ((SUB (VARIABLE-SUBSTITUTION VAR)))
    (DELIVER-VALUE-TO-CONT
     (IF (CONSP SUB)
         (CASE (CAR SUB)
           ((SCHEME::VAL) (CADR SUB))
           ((SCHEME::FUN) (CONS 'FUNCTION (LIST (CADR SUB))))
           (OTHERWISE (.ERROR "lossage in generate-local-variable" SUB)))
         SUB)
     CONT)))
(SET-VALUE-FROM-FUNCTION 'GENERATE-LOCAL-VARIABLE
                         'SCHEME::GENERATE-LOCAL-VARIABLE)
(DEFUN GENERATE-PROGRAM-VARIABLE (VAR ENV CONT)
  ENV
  (LET ((SUB (GET-INTEGRATION VAR)))
    (DELIVER-VALUE-TO-CONT
     (IF (CONSP SUB)
         (CASE (CAR SUB)
           ((SCHEME::VAL) (CADR SUB))
           ((SCHEME::FUN) (CONS 'FUNCTION (LIST (CADR SUB))))
           (OTHERWISE
            (NOTE-VARIABLE-REFERENCE! VAR)
            (PROGRAM-VARIABLE-CL-SYMBOL VAR)))
         (PROGN
          (NOTE-VARIABLE-REFERENCE! VAR)
          (PROGRAM-VARIABLE-CL-SYMBOL VAR)))
     CONT)))
(SET-VALUE-FROM-FUNCTION 'GENERATE-PROGRAM-VARIABLE
                         'SCHEME::GENERATE-PROGRAM-VARIABLE)
(DEFUN GET-INTEGRATION (VAR)
  (DECLARE (SPECIAL INTEGRATIONS-TABLE))
  (TABLE-REF INTEGRATIONS-TABLE VAR))
(SET-VALUE-FROM-FUNCTION 'GET-INTEGRATION 'SCHEME::GET-INTEGRATION)
(LOCALLY
 (DECLARE (SPECIAL *DECLARE-PROGRAM-VARIABLES-SPECIAL?*))
 (SETQ *DECLARE-PROGRAM-VARIABLES-SPECIAL?* TRUE))
(SET-FORWARDING-FUNCTION '*DECLARE-PROGRAM-VARIABLES-SPECIAL?*
                         'SCHEME::*DECLARE-PROGRAM-VARIABLES-SPECIAL?*)
(DEFUN NOTE-VARIABLE-REFERENCE! (VAR)
  (DECLARE
   (SPECIAL @CL-VARIABLE-REFERENCES *DECLARE-PROGRAM-VARIABLES-SPECIAL?*))
  (IF
   (AND (NOT (TRUEP (QUALIFIED-SYMBOL? (PROGRAM-VARIABLE-NAME VAR))))
        (TRUEP *DECLARE-PROGRAM-VARIABLES-SPECIAL?*))
   (LET ((G (FLUID @CL-VARIABLE-REFERENCES)))
     (IF
      (AND (NOT (EQ G 'SCHEME::DONT-ACCUMULATE))
           (NOT (MEMBER VAR G :TEST #'EQ)))
      (SET-FLUID! @CL-VARIABLE-REFERENCES (CONS VAR G))))))
(SET-VALUE-FROM-FUNCTION 'NOTE-VARIABLE-REFERENCE!
                         'SCHEME::NOTE-VARIABLE-REFERENCE!)
(DEFUN GENERATE-CALL (NODE ENV CONT)
  (LET ((PROC (CALL-PROC NODE)) (ARGS (CALL-ARGS NODE)))
    (CASE (NODE-TYPE PROC)
      ((SCHEME::PROGRAM-VARIABLE)
       (IF (TRUEP (MUTABLE-PROGRAM-VARIABLE? PROC))
           (GENERATE-GENERAL-CALL PROC ARGS ENV CONT)
           (GENERATE-CALL-TO-PROGRAM-VARIABLE PROC ARGS ENV CONT)))
      ((SCHEME::LOCAL-VARIABLE)
       (IF
        (AND (CONSP (VARIABLE-SUBSTITUTION PROC))
             (EQ (CAR (VARIABLE-SUBSTITUTION PROC))
                 'SCHEME::--GENERATE-CALL--))
        (FUNCALL (CADR (VARIABLE-SUBSTITUTION PROC))
                 (GENERATE-LIST ARGS ENV)
                 CONT)
        (GENERATE-GENERAL-CALL PROC ARGS ENV CONT)))
      ((SCHEME::LAMBDA)
       (IF
        (AND (NOT (TRUEP (N-ARY? PROC)))
             (= (LENGTH ARGS) (LENGTH (LAMBDA-VARS PROC))))
        (GENERATE-LET PROC ARGS ENV CONT)
        (GENERATE-GENERAL-CALL PROC ARGS ENV CONT)))
      (OTHERWISE (GENERATE-GENERAL-CALL PROC ARGS ENV CONT)))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-CALL 'SCHEME::GENERATE-CALL)
(DEFUN GENERATE-GENERAL-CALL (PROC ARGS ENV CONT)
  (DECLARE (SPECIAL CONT/VALUE))
  (DELIVER-VALUE-TO-CONT
   (FUNCALLIFY (GENERATE PROC ENV CONT/VALUE) (GENERATE-LIST ARGS ENV))
   CONT))
(SET-VALUE-FROM-FUNCTION 'GENERATE-GENERAL-CALL 'SCHEME::GENERATE-GENERAL-CALL)
(DEFUN GENERATE-CALL-TO-PROGRAM-VARIABLE (PVAR ARGS ENV CONT)
  (DECLARE (SPECIAL CONT/TEST))
  (LET ((SUB (GET-INTEGRATION PVAR)))
    (IF (NOT (CONSP SUB))
        (GENERATE-CALL-TO-UNKNOWN PVAR ARGS ENV CONT)
        (CASE (CAR SUB)
          ((SCHEME::SUBST)
           (LET ((PARAMS (CADR SUB)) (BODY (PROGNIFY (CDDR SUB))))
             (IF (= (LENGTH ARGS) (LENGTH PARAMS))
                 (SUBSTITUTE-AND-PEEP
                  (MAPCAR #'CONS PARAMS (GENERATE-LIST ARGS ENV))
                  (DELIVER-VALUE-TO-CONT BODY CONT))
                 (PROGN
                  (NOTE "wrong number of arguments" (MAKE-CALL PVAR ARGS))
                  (GENERATE-CALL-TO-UNKNOWN PVAR ARGS ENV CONT)))))
          ((SCHEME::LAMBDA)
           (IF (= (LENGTH ARGS) (LENGTH (CADR SUB)))
               (CONS 'LET
                     (CONS (MAPCAR #'LIST (CADR SUB) (GENERATE-LIST ARGS ENV))
                           (DEPROGNIFY
                            (DELIVER-VALUE-TO-CONT (PROGNIFY (CDDR SUB))
                                                   CONT))))
               (GENERATE-CALL-TO-UNKNOWN PVAR ARGS ENV CONT)))
          ((SCHEME::FUN)
           (DELIVER-VALUE-TO-CONT (CONS (CADR SUB) (GENERATE-LIST ARGS ENV))
                                  CONT))
          ((SCHEME::PRED)
           (DELIVER-TEST-TO-CONT (CONS (CADR SUB) (GENERATE-LIST ARGS ENV))
                                 CONT))
          ((SCHEME::VAL)
           (DELIVER-VALUE-TO-CONT
            (FUNCALLIFY (CADR SUB) (GENERATE-LIST ARGS ENV))
            CONT))
          ((SCHEME::SPECIAL)
           (CASE (PROGRAM-VARIABLE-NAME PVAR)
             ((SCHEME::NOT)
              (IF (= (LENGTH ARGS) 1)
                  (DELIVER-TEST-TO-CONT
                   (CONS 'NOT (LIST (GENERATE (CAR ARGS) ENV CONT/TEST)))
                   CONT)
                  (GENERATE-CALL-TO-UNKNOWN PVAR ARGS ENV CONT)))
             ((SCHEME::AND-AUX)
              (GENERATE-AND (CAR ARGS)
                            (IF (TRUEP (LAMBDA? (CADR ARGS)))
                                (LAMBDA-BODY (CADR ARGS))
                                (MAKE-CALL (CADR ARGS) 'NIL))
                            ENV
                            CONT))
             ((SCHEME::OR-AUX)
              (GENERATE-OR (CAR ARGS)
                           (IF (TRUEP (LAMBDA? (CADR ARGS)))
                               (LAMBDA-BODY (CADR ARGS))
                               (MAKE-CALL (CADR ARGS) 'NIL))
                           ENV
                           CONT))
             ((SCHEME::CASE-AUX)
              (GENERATE-CASE (CAR ARGS)
                             (CADR ARGS)
                             (CADDR ARGS)
                             (CDDDR ARGS)
                             ENV
                             CONT))
             ((SCHEME::=>-AUX)
              (LET ((PROC-THUNK (CADR ARGS)))
                (LET ((PROC
                       (IF (TRUEP (LAMBDA? PROC-THUNK))
                           (LAMBDA-BODY PROC-THUNK)
                           (MAKE-CALL PROC-THUNK 'NIL))))
                  (LET ()
                    (IF
                     (AND (TRUEP (LAMBDA? PROC))
                          (= (LENGTH (LAMBDA-VARS PROC)) 1))
                     (GENERATE-=> (CAR ARGS)
                                  (CAR (LAMBDA-VARS PROC))
                                  (LAMBDA-BODY PROC)
                                  (CADDR ARGS)
                                  ENV
                                  CONT)
                     (LET ((VAR (MAKE-LOCAL-VARIABLE 'SCHEME::TEMP)))
                       (GENERATE-=> (CAR ARGS)
                                    VAR
                                    (MAKE-CALL PROC (LIST VAR))
                                    (CADDR ARGS)
                                    ENV
                                    CONT)))))))
             (OTHERWISE (.ERROR "losing built-in" PVAR))))
          (OTHERWISE (.ERROR "losing CASE" SUB))))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-CALL-TO-PROGRAM-VARIABLE
                         'SCHEME::GENERATE-CALL-TO-PROGRAM-VARIABLE)
(DEFUN GENERATE-AND (FIRST SECOND ENV CONT)
  (DECLARE (SPECIAL CONT/TEST))
  (CASE (CONTINUATION-TYPE CONT)
    ((SCHEME::CONT/TEST SCHEME::CONT/IGNORE)
     (CONS 'AND
           (CONS (GENERATE FIRST ENV CONT/TEST)
                 (DEANDIFY (GENERATE SECOND ENV CONT/TEST)))))
    (OTHERWISE
     (CONS 'IF
           (CONS (GENERATE FIRST ENV CONT/TEST)
                 (CONS (GENERATE SECOND ENV CONT)
                       (LIST (DELIVER-VALUE-TO-CONT 'FALSE CONT))))))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-AND 'SCHEME::GENERATE-AND)
(DEFUN GENERATE-OR (FIRST SECOND ENV CONT)
  (DECLARE (SPECIAL CONT/VALUE CONT/TEST))
  (CASE (CONTINUATION-TYPE CONT)
    ((SCHEME::CONT/TEST SCHEME::CONT/IGNORE)
     (CONS 'OR
           (CONS (GENERATE FIRST ENV CONT/TEST)
                 (DEORIFY (GENERATE SECOND ENV CONT)))))
    (OTHERWISE
     (LET ((FIRST-CODE (GENERATE FIRST ENV CONT/VALUE)))
       (IF (TRUEP (CAR-IS? FIRST-CODE 'TRUE?))
           (CONS 'OR
                 (CONS (CADR FIRST-CODE) (DEORIFY (GENERATE SECOND ENV CONT))))
           (LET ((VAR (MAKE-LOCAL-VARIABLE 'SCHEME::TEMP)))
             (LET ((NEW-NAME (CL-EXTERNALIZE-LOCAL 'SCHEME::TEMP ENV)))
               (LET ((NEW-ENV (BIND-VARIABLES (LIST VAR) (LIST NEW-NAME) ENV)))
                 (LET ()
                   (CONS 'LET
                         (CONS (LIST (CONS NEW-NAME (LIST FIRST-CODE)))
                               (LIST
                                (CONS 'IF
                                      (CONS (CONS 'TRUEP (LIST NEW-NAME))
                                            (CONS
                                             (DELIVER-VALUE-TO-CONT NEW-NAME
                                                                    CONT)
                                             (LIST
                                              (GENERATE SECOND
                                                        NEW-ENV
                                                        CONT)))))))))))))))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-OR 'SCHEME::GENERATE-OR)
(DEFUN GENERATE-CASE (KEY KEY-LISTS ELSE-THUNK THUNKS ENV CONT)
  (DECLARE (SPECIAL CONT/VALUE))
  (CONS 'CASE
        (CONS (GENERATE KEY ENV CONT/VALUE)
              (APPEND
               (MAPCAR
                #'(LAMBDA (KEY-LIST THUNK)
                    (CONS KEY-LIST
                          (DEPROGNIFY
                           (GENERATE
                            (IF (TRUEP (LAMBDA? THUNK))
                                (LAMBDA-BODY THUNK)
                                (MAKE-CALL THUNK 'NIL))
                            ENV
                            CONT))))
                (IF (TRUEP (CONSTANT? KEY-LISTS))
                    (CONSTANT-VALUE KEY-LISTS)
                    (.ERROR "case: invalid key-lists" KEY-LISTS))
                THUNKS)
               (LIST
                (CONS 'OTHERWISE
                      (DEPROGNIFY
                       (GENERATE
                        (IF (TRUEP (LAMBDA? ELSE-THUNK))
                            (LAMBDA-BODY ELSE-THUNK)
                            (MAKE-CALL ELSE-THUNK 'NIL))
                        ENV
                        CONT))))))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-CASE 'SCHEME::GENERATE-CASE)
(DEFUN GENERATE-=> (TEST VAR THEN ELSE-THUNK ENV CONT)
  (DECLARE (SPECIAL CONT/VALUE))
  (LET ((NEW-NAME (CL-EXTERNALIZE-LOCAL (LOCAL-VARIABLE-NAME VAR) ENV)))
    (LET ((NEW-ENV (BIND-VARIABLES (LIST VAR) (LIST NEW-NAME) ENV)))
      (LET ()
        (CONS 'LET
              (CONS
               (LIST (CONS NEW-NAME (LIST (GENERATE TEST ENV CONT/VALUE))))
               (LIST
                (CONS 'IF
                      (CONS (CONS 'TRUEP (LIST NEW-NAME))
                            (CONS (GENERATE THEN NEW-ENV CONT)
                                  (LIST
                                   (GENERATE
                                    (IF (TRUEP (LAMBDA? ELSE-THUNK))
                                        (LAMBDA-BODY ELSE-THUNK)
                                        (MAKE-CALL ELSE-THUNK 'NIL))
                                    NEW-ENV
                                    CONT))))))))))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-=> 'SCHEME::GENERATE-=>)
(DEFUN GENERATE-CALL-TO-UNKNOWN (PVAR ARGS ENV CONT)
  (LET ((CL-SYM (PROGRAM-VARIABLE-CL-SYMBOL PVAR))
        (ARGS-CODE (GENERATE-LIST ARGS ENV)))
    (DELIVER-VALUE-TO-CONT
     (IF
      (AND (NOT (TRUEP (QUALIFIED-SYMBOL? CL-SYM)))
           (TRUEP (DEFINED-AS-CL-MACRO? CL-SYM)))
      (CONS 'FUNCALL (CONS CL-SYM ARGS-CODE))
      (CONS CL-SYM ARGS-CODE))
     CONT)))
(SET-VALUE-FROM-FUNCTION 'GENERATE-CALL-TO-UNKNOWN
                         'SCHEME::GENERATE-CALL-TO-UNKNOWN)
(DEFUN GENERATE-LAMBDA (NODE ENV CONT)
  (DECLARE (SPECIAL CONT/VALUE @LAMBDA-ENCOUNTERED?))
  (SET-FLUID! @LAMBDA-ENCOUNTERED? TRUE)
  (DELIVER-VALUE-TO-CONT
   (CONS 'FUNCTION
         (LIST (CONS 'LAMBDA (GENERATE-LAMBDA-AUX NODE ENV CONT/VALUE))))
   CONT))
(SET-VALUE-FROM-FUNCTION 'GENERATE-LAMBDA 'SCHEME::GENERATE-LAMBDA)
(DEFUN GENERATE-LAMBDA-AUX (NODE ENV CONT)
  (LET ((BVL (LAMBDA-VARS NODE)))
    (LET ((VARS (PROPER-LISTIFY BVL)))
      (LET ((NEW-NAMES (CL-EXTERNALIZE-LOCALS VARS ENV)))
        (LET ((NEW-ENV (BIND-VARIABLES VARS NEW-NAMES ENV)))
          (LET ((BODY-CODE (GENERATE-BODY (LAMBDA-BODY NODE) NEW-ENV CONT)))
            (LET ()
              (IF (TRUEP (N-ARY? NODE))
                  (LET ((.BVL.0 (INSERT-&REST NEW-NAMES)))
                    (LET ((REST-VAR (CAR (LAST-PAIR .BVL.0))))
                      (LET ()
                        (CONS .BVL.0
                              (CONS
                               (CONS 'MAYBE-FIX-&REST-PARAMETER
                                     (LIST REST-VAR))
                               BODY-CODE)))))
                  (CONS NEW-NAMES BODY-CODE)))))))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-LAMBDA-AUX 'SCHEME::GENERATE-LAMBDA-AUX)
(DEFUN GENERATE-LET (PROC ARGS ENV CONT)
  (DECLARE (SPECIAL CONT/VALUE))
  (LET ((VARS (LAMBDA-VARS PROC)))
    (IF (TRUEP (FUNCTION-BINDABLE? VARS ARGS))
        (LET ((NEW-NAMES (CL-EXTERNALIZE-LOCALS VARS ENV)))
          (LET ((NEW-ENV (BIND-FUNCTIONS VARS NEW-NAMES ENV)))
            (LET ()
              (CONS 'FLET
                    (CONS
                     (MAPCAR
                      #'(LAMBDA (NEW-NAME .PROC.0)
                          (CONS NEW-NAME
                                (GENERATE-LAMBDA-AUX .PROC.0 ENV CONT/VALUE)))
                      NEW-NAMES
                      ARGS)
                     (GENERATE-BODY (LAMBDA-BODY PROC) NEW-ENV CONT))))))
        (LET ((BVL+BODY (GENERATE-LAMBDA-AUX PROC ENV CONT)))
          (CONS 'LET
                (CONS (MAPCAR #'LIST (CAR BVL+BODY) (GENERATE-LIST ARGS ENV))
                      (CDR BVL+BODY)))))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-LET 'SCHEME::GENERATE-LET)
(DEFUN GENERATE-IF (NODE ENV CONT)
  (DECLARE (SPECIAL CONT/TEST @TRANSLATING-TO-FILE?))
  (LET ((TEST (GENERATE (IF-TEST NODE) ENV CONT/TEST))
        (CON (GENERATE (IF-CON NODE) ENV CONT))
        (ALT (GENERATE (IF-ALT NODE) ENV CONT)))
    (IF
     (AND (EQ ALT 'UNSPECIFIC)
          (OR (EQ (CONTINUATION-TYPE CONT) 'SCHEME::CONT/IGNORE)
              (TRUEP (FLUID @TRANSLATING-TO-FILE?))))
     (CONS 'IF (CONS TEST (LIST CON)))
     (CONS 'IF (CONS TEST (CONS CON (LIST ALT)))))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-IF 'SCHEME::GENERATE-IF)
(DEFUN GENERATE-BEGIN (NODE ENV CONT)
  (DECLARE (SPECIAL CONT/IGNORE))
  (PROGNIFY
   (APPEND (DEPROGNIFY (GENERATE (BEGIN-FIRST NODE) ENV CONT/IGNORE))
           (DEPROGNIFY (GENERATE (BEGIN-SECOND NODE) ENV CONT)))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-BEGIN 'SCHEME::GENERATE-BEGIN)
(DEFUN GENERATE-SET! (NODE ENV CONT)
  (DECLARE (SPECIAL CONT/VALUE))
  (LET ((VAR (SET!-LHS NODE))
        (RHS-CODE (GENERATE (SET!-RHS NODE) ENV CONT/VALUE)))
    (IF (TRUEP (PROGRAM-VARIABLE? VAR))
        (PROGN
         (IF (TRUEP (GET-INTEGRATION VAR))
             (NOTE "SET! of an integrated variable" NODE))
         (LET ((CL-SYM (PROGRAM-VARIABLE-CL-SYMBOL VAR)))
           (NOTE-VARIABLE-REFERENCE! VAR)
           (DELIVER-VALUE-TO-CONT
            (EMIT-PROGRAM-VARIABLE-SET! VAR CL-SYM RHS-CODE)
            CONT)))
        (LET ((THE-SETQ
               (CONS 'SETQ (CONS (VARIABLE-SUBSTITUTION VAR) (LIST RHS-CODE)))))
          (IF (EQ (CONTINUATION-TYPE CONT) 'SCHEME::CONT/IGNORE)
              THE-SETQ
              (CONS 'PROGN
                    (CONS THE-SETQ
                          (LIST (DELIVER-VALUE-TO-CONT 'UNSPECIFIC CONT)))))))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-SET! 'SCHEME::GENERATE-SET!)
(DEFUN GENERATE-LETREC (NODE ENV CONT)
  (CASE (GET-LETREC-STRATEGY NODE)
    ((SCHEME::GENERAL) (GENERATE-GENERAL-LETREC NODE ENV CONT))
    ((SCHEME::LABELS) (GENERATE-LABELS-LETREC NODE ENV CONT))
    ((SCHEME::PROG) (GENERATE-PROG-LETREC NODE ENV CONT))
    (OTHERWISE (.ERROR "unknown strategy" (GET-LETREC-STRATEGY NODE)))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-LETREC 'SCHEME::GENERATE-LETREC)
(DEFUN GENERATE-GENERAL-LETREC (NODE ENV CONT)
  (DECLARE (SPECIAL CONT/VALUE))
  (LET ((VARS (LETREC-VARS NODE)))
    (LET ((VALS (LETREC-VALS NODE)))
      (LET ((NEW-NAMES (CL-EXTERNALIZE-LOCALS VARS ENV)))
        (LET ((NEW-ENV (BIND-VARIABLES VARS NEW-NAMES ENV)))
          (LET ()
            (CONS 'LET
                  (CONS
                   (MAPCAR #'(LAMBDA (NEW-NAME) (CONS NEW-NAME '(UNASSIGNED)))
                           NEW-NAMES)
                   (APPEND
                    (MAPCAR
                     #'(LAMBDA (VAR VAL)
                         (CONS 'SETQ
                               (CONS VAR
                                     (LIST
                                      (GENERATE VAL NEW-ENV CONT/VALUE)))))
                     NEW-NAMES
                     VALS)
                    (DEPROGNIFY
                     (GENERATE (LETREC-BODY NODE) NEW-ENV CONT)))))))))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-GENERAL-LETREC
                         'SCHEME::GENERATE-GENERAL-LETREC)
(DEFUN GENERATE-LABELS-LETREC (NODE ENV CONT)
  (DECLARE (SPECIAL CONT/VALUE))
  (LET ((VARS (LETREC-VARS NODE)))
    (LET ((VALS (LETREC-VALS NODE)))
      (LET ((NEW-NAMES (CL-EXTERNALIZE-LOCALS VARS ENV)))
        (LET ((NEW-ENV (BIND-FUNCTIONS VARS NEW-NAMES ENV)))
          (LET ()
            (CONS 'LABELS
                  (CONS
                   (MAPCAR
                    #'(LAMBDA (NEW-NAME PROC)
                        (CONS NEW-NAME
                              (GENERATE-LAMBDA-AUX PROC NEW-ENV CONT/VALUE)))
                    NEW-NAMES
                    VALS)
                   (GENERATE-BODY (LETREC-BODY NODE) NEW-ENV CONT)))))))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-LABELS-LETREC
                         'SCHEME::GENERATE-LABELS-LETREC)
(DEFUN GENERATE-PROG-LETREC (NODE ENV CONT)
  (DECLARE (SPECIAL CONT/RETURN SET-LETREC-SUBSTITUTION!))
  (LET ((VARS (LETREC-VARS NODE)))
    (LET ((PROCS (LETREC-VALS NODE)))
      (LET ((NEW-NAMES (CL-EXTERNALIZE-LOCALS VARS ENV)))
        (LET ((NEW-ENV (BIND-VARIABLES VARS NEW-NAMES ENV)))
          (LET ((TEMP-LISTS
                 (MAPCAR
                  #'(LAMBDA (PROC)
                      (MAPCAR
                       #'(LAMBDA (VAR)
                           (IF (TRUEP (VARIABLE-CLOSED-OVER? VAR))
                               (MAKE-NAME-FROM-UID (LOCAL-VARIABLE-NAME VAR)
                                                   (GENERATE-UID))
                               FALSE))
                       (LAMBDA-VARS PROC)))
                  PROCS)))
            (LET ((PROC-NEW-NAMESES
                   (MAPCAR
                    #'(LAMBDA (PROC)
                        (CL-EXTERNALIZE-LOCALS (LAMBDA-VARS PROC) NEW-ENV))
                    PROCS)))
              (LET ((PROC-ENVS
                     (MAPCAR
                      #'(LAMBDA (PROC .NEW-NAMES.2)
                          (BIND-VARIABLES (LAMBDA-VARS PROC)
                                          .NEW-NAMES.2
                                          NEW-ENV))
                      PROCS
                      PROC-NEW-NAMESES)))
                (LET ()
                  (MAPC SET-LETREC-SUBSTITUTION!
                        VARS
                        NEW-NAMES
                        PROC-NEW-NAMESES
                        TEMP-LISTS)
                  (DELIVER-VALUE-TO-CONT
                   (CONS 'PROG
                         (CONS
                          (APPLY #'APPEND
                                 (MAPCAR
                                  #'(LAMBDA (TEMP-LIST .NEW-NAMES.0)
                                      (MAPCAR
                                       #'(LAMBDA (TEMP NEW-NAME)
                                           (LET ((.TEMP.1 TEMP))
                                             (IF (TRUEP .TEMP.1)
                                                 .TEMP.1
                                                 NEW-NAME)))
                                       TEMP-LIST
                                       .NEW-NAMES.0))
                                  TEMP-LISTS
                                  PROC-NEW-NAMESES))
                          (APPEND
                           (GENERATE-BODY (LETREC-BODY NODE)
                                          NEW-ENV
                                          CONT/RETURN)
                           (APPLY #'APPEND
                                  (MAPCAR
                                   #'(LAMBDA
                                         (NEW-NAME PROC TEMP-LIST
                                          PROC-NEW-NAMES PROC-ENV)
                                       (CONS NEW-NAME
                                             (LIST
                                              (LETIFY
                                               (FILTER #'CADR
                                                       (MAPCAR #'LIST
                                                               PROC-NEW-NAMES
                                                               TEMP-LIST))
                                               (GENERATE (LAMBDA-BODY PROC)
                                                         PROC-ENV
                                                         CONT/RETURN)))))
                                   NEW-NAMES
                                   PROCS
                                   TEMP-LISTS
                                   PROC-NEW-NAMESES
                                   PROC-ENVS)))))
                   CONT))))))))))
(SET-VALUE-FROM-FUNCTION 'GENERATE-PROG-LETREC 'SCHEME::GENERATE-PROG-LETREC)
(DEFUN SET-LETREC-SUBSTITUTION! (VAR NEW-NAME PROC-NEW-NAMES TEMP-LIST)
  (SET-SUBSTITUTION! VAR
                     (LIST 'SCHEME::--GENERATE-CALL--
                           #'(LAMBDA (ARGS CONT)
                               (IF
                                (NOT
                                 (EQ (CONTINUATION-TYPE CONT)
                                     'SCHEME::CONT/RETURN))
                                (NOTE "screwed-up LETREC" CONT))
                               (IF (NULL ARGS)
                                   (CONS 'GO (LIST NEW-NAME))
                                   (CONS 'PROGN
                                         (CONS
                                          (CONS
                                           (IF (NULL (CDR ARGS)) 'SETQ 'PSETQ)
                                           (APPLY #'APPEND
                                                  (MAPCAR
                                                   #'(LAMBDA
                                                         (.NEW-NAME.0 TEMP
                                                          ACTUAL)
                                                       (CONS
                                                        (LET ((.TEMP.1 TEMP))
                                                          (IF (TRUEP .TEMP.1)
                                                              .TEMP.1
                                                              .NEW-NAME.0))
                                                        (LIST ACTUAL)))
                                                   PROC-NEW-NAMES
                                                   TEMP-LIST
                                                   ARGS)))
                                          (LIST
                                           (CONS 'GO (LIST NEW-NAME))))))))))
(SET-VALUE-FROM-FUNCTION 'SET-LETREC-SUBSTITUTION!
                         'SCHEME::SET-LETREC-SUBSTITUTION!)
